import {
  List_default
} from "./chunk-AWJ3P6JK.js";
import {
  Popover_default
} from "./chunk-GWQO3PIC.js";
import {
  getScrollbarSize
} from "./chunk-FILLQTIP.js";
import {
  init_useTheme,
  useTheme
} from "./chunk-NVGMITRW.js";
import {
  init_ownerDocument,
  ownerDocument
} from "./chunk-BDCKQYXW.js";
import {
  deprecatedPropType,
  init_deprecatedPropType
} from "./chunk-EU4TR4YR.js";
import {
  init_setRef,
  init_useForkRef,
  setRef,
  useForkRef
} from "./chunk-I4AUBGLO.js";
import {
  require_react_dom
} from "./chunk-3XI55KIC.js";
import {
  init_withStyles,
  withStyles_default
} from "./chunk-FWBHA4J6.js";
import {
  HTMLElementType,
  _objectWithoutProperties,
  init_esm,
  init_objectWithoutProperties
} from "./chunk-AW56PTTK.js";
import {
  _extends,
  init_extends
} from "./chunk-DQPHAHAW.js";
import {
  require_prop_types,
  require_react_is
} from "./chunk-QHXF6CUT.js";
import {
  clsx_m_default,
  init_clsx_m
} from "./chunk-RA6GVHQM.js";
import {
  require_react
} from "./chunk-42CJYN7C.js";
import {
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/@material-ui/core/esm/MenuList/MenuList.js
init_extends();
init_objectWithoutProperties();
var React = __toESM(require_react());
var import_react_is = __toESM(require_react_is());
var import_prop_types = __toESM(require_prop_types());
var ReactDOM = __toESM(require_react_dom());
init_ownerDocument();
init_useForkRef();
function nextItem(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  var text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.indexOf(textCriteria.keys.join("")) === 0;
}
function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  var wrappedOnce = false;
  var nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }
    var nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return;
    }
  }
}
var useEnhancedEffect = typeof window === "undefined" ? React.useEffect : React.useLayoutEffect;
var MenuList = React.forwardRef(function MenuList2(props, ref) {
  var actions = props.actions, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus, _props$autoFocusItem = props.autoFocusItem, autoFocusItem = _props$autoFocusItem === void 0 ? false : _props$autoFocusItem, children = props.children, className = props.className, _props$disabledItemsF = props.disabledItemsFocusable, disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF, _props$disableListWra = props.disableListWrap, disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra, onKeyDown = props.onKeyDown, _props$variant = props.variant, variant = _props$variant === void 0 ? "selectedMenu" : _props$variant, other = _objectWithoutProperties(props, ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"]);
  var listRef = React.useRef(null);
  var textCriteriaRef = React.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(function() {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  React.useImperativeHandle(actions, function() {
    return {
      adjustStyleForScrollbar: function adjustStyleForScrollbar(containerElement, theme) {
        var noExplicitWidth = !listRef.current.style.width;
        if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
          var scrollbarSize = "".concat(getScrollbarSize(true), "px");
          listRef.current.style[theme.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
          listRef.current.style.width = "calc(100% + ".concat(scrollbarSize, ")");
        }
        return listRef.current;
      }
    };
  }, []);
  var handleKeyDown = function handleKeyDown2(event) {
    var list = listRef.current;
    var key = event.key;
    var currentFocus = ownerDocument(list).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key.length === 1) {
      var criteria = textCriteriaRef.current;
      var lowerKey = key.toLowerCase();
      var currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      var keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  var handleOwnRef = React.useCallback(function(instance) {
    listRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  var handleRef = useForkRef(handleOwnRef, ref);
  var activeItemIndex = -1;
  React.Children.forEach(children, function(child, index) {
    if (!React.isValidElement(child)) {
      return;
    }
    if (true) {
      if ((0, import_react_is.isFragment)(child)) {
        console.error(["Material-UI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
      }
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  var items = React.Children.map(children, function(child, index) {
    if (index === activeItemIndex) {
      var newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return React.cloneElement(child, newChildProps);
    }
    return child;
  });
  return React.createElement(List_default, _extends({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown,
    tabIndex: autoFocus ? 0 : -1
  }, other), items);
});
true ? MenuList.propTypes = {
  autoFocus: import_prop_types.default.bool,
  autoFocusItem: import_prop_types.default.bool,
  children: import_prop_types.default.node,
  className: import_prop_types.default.string,
  disabledItemsFocusable: import_prop_types.default.bool,
  disableListWrap: import_prop_types.default.bool,
  onKeyDown: import_prop_types.default.func,
  variant: import_prop_types.default.oneOf(["menu", "selectedMenu"])
} : void 0;
var MenuList_default = MenuList;

// node_modules/@material-ui/core/esm/Menu/Menu.js
init_extends();
init_objectWithoutProperties();
var React2 = __toESM(require_react());
var import_react_is2 = __toESM(require_react_is());
var import_prop_types2 = __toESM(require_prop_types());
init_clsx_m();
init_esm();
init_withStyles();
var ReactDOM2 = __toESM(require_react_dom());
init_setRef();
init_useTheme();
init_deprecatedPropType();
var RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
var LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
var styles = {
  paper: {
    maxHeight: "calc(100% - 96px)",
    WebkitOverflowScrolling: "touch"
  },
  list: {
    outline: 0
  }
};
var Menu = React2.forwardRef(function Menu2(props, ref) {
  var _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, children = props.children, classes = props.classes, _props$disableAutoFoc = props.disableAutoFocusItem, disableAutoFocusItem = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$MenuListProps = props.MenuListProps, MenuListProps = _props$MenuListProps === void 0 ? {} : _props$MenuListProps, onClose = props.onClose, onEnteringProp = props.onEntering, open = props.open, _props$PaperProps = props.PaperProps, PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps, PopoverClasses = props.PopoverClasses, _props$transitionDura = props.transitionDuration, transitionDuration = _props$transitionDura === void 0 ? "auto" : _props$transitionDura, _props$TransitionProp = props.TransitionProps;
  _props$TransitionProp = _props$TransitionProp === void 0 ? {} : _props$TransitionProp;
  var onEntering = _props$TransitionProp.onEntering, TransitionProps = _objectWithoutProperties(_props$TransitionProp, ["onEntering"]), _props$variant = props.variant, variant = _props$variant === void 0 ? "selectedMenu" : _props$variant, other = _objectWithoutProperties(props, ["autoFocus", "children", "classes", "disableAutoFocusItem", "MenuListProps", "onClose", "onEntering", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"]);
  var theme = useTheme();
  var autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  var menuListActionsRef = React2.useRef(null);
  var contentAnchorRef = React2.useRef(null);
  var getContentAnchorEl = function getContentAnchorEl2() {
    return contentAnchorRef.current;
  };
  var handleEntering = function handleEntering2(element, isAppearing) {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
    }
    if (onEnteringProp) {
      onEnteringProp(element, isAppearing);
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  var handleListKeyDown = function handleListKeyDown2(event) {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  var activeItemIndex = -1;
  React2.Children.map(children, function(child, index) {
    if (!React2.isValidElement(child)) {
      return;
    }
    if (true) {
      if ((0, import_react_is2.isFragment)(child)) {
        console.error(["Material-UI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
      }
    }
    if (!child.props.disabled) {
      if (variant !== "menu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  var items = React2.Children.map(children, function(child, index) {
    if (index === activeItemIndex) {
      return React2.cloneElement(child, {
        ref: function ref2(instance) {
          contentAnchorRef.current = ReactDOM2.findDOMNode(instance);
          setRef(child.ref, instance);
        }
      });
    }
    return child;
  });
  return React2.createElement(Popover_default, _extends({
    getContentAnchorEl,
    classes: PopoverClasses,
    onClose,
    TransitionProps: _extends({
      onEntering: handleEntering
    }, TransitionProps),
    anchorOrigin: theme.direction === "rtl" ? RTL_ORIGIN : LTR_ORIGIN,
    transformOrigin: theme.direction === "rtl" ? RTL_ORIGIN : LTR_ORIGIN,
    PaperProps: _extends({}, PaperProps, {
      classes: _extends({}, PaperProps.classes, {
        root: classes.paper
      })
    }),
    open,
    ref,
    transitionDuration
  }, other), React2.createElement(MenuList_default, _extends({
    onKeyDown: handleListKeyDown,
    actions: menuListActionsRef,
    autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
    autoFocusItem,
    variant
  }, MenuListProps, {
    className: clsx_m_default(classes.list, MenuListProps.className)
  }), items));
});
true ? Menu.propTypes = {
  anchorEl: import_prop_types2.default.oneOfType([HTMLElementType, import_prop_types2.default.func]),
  autoFocus: import_prop_types2.default.bool,
  children: import_prop_types2.default.node,
  classes: import_prop_types2.default.object,
  disableAutoFocusItem: import_prop_types2.default.bool,
  MenuListProps: import_prop_types2.default.object,
  onClose: import_prop_types2.default.func,
  onEnter: deprecatedPropType(import_prop_types2.default.func, "Use the `TransitionProps` prop instead."),
  onEntered: deprecatedPropType(import_prop_types2.default.func, "Use the `TransitionProps` prop instead."),
  onEntering: deprecatedPropType(import_prop_types2.default.func, "Use the `TransitionProps` prop instead."),
  onExit: deprecatedPropType(import_prop_types2.default.func, "Use the `TransitionProps` prop instead."),
  onExited: deprecatedPropType(import_prop_types2.default.func, "Use the `TransitionProps` prop instead."),
  onExiting: deprecatedPropType(import_prop_types2.default.func, "Use the `TransitionProps` prop instead."),
  open: import_prop_types2.default.bool.isRequired,
  PaperProps: import_prop_types2.default.object,
  PopoverClasses: import_prop_types2.default.object,
  transitionDuration: import_prop_types2.default.oneOfType([import_prop_types2.default.oneOf(["auto"]), import_prop_types2.default.number, import_prop_types2.default.shape({
    appear: import_prop_types2.default.number,
    enter: import_prop_types2.default.number,
    exit: import_prop_types2.default.number
  })]),
  TransitionProps: import_prop_types2.default.object,
  variant: import_prop_types2.default.oneOf(["menu", "selectedMenu"])
} : void 0;
var Menu_default = withStyles_default(styles, {
  name: "MuiMenu"
})(Menu);

export {
  MenuList_default,
  Menu_default
};
//# sourceMappingURL=chunk-ETCDZNYQ.js.map
